package com.orasi.utils.rest;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.TextNode;
import com.orasi.text.TemplateFormat;
import com.orasi.utils.types.DefaultingMap;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Request;
import com.squareup.okhttp.Response;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.text.MessageFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Level;
import java.util.logging.Logger;
import okio.Okio;
import org.apache.commons.lang3.StringUtils;
import org.testng.Assert;

/**
 * The PostmanCollection allows one to load a Postman Collection file, which
 * is just a specially formatted JSON file. It describes a user-selected group
 * of queries which have been saved in Postman. The collection contains a group
 * of requests, which also potentially have a number of responses. These
 * responses were generated by making a request in Postman and then clicking
 * the bookmark icon in Postman.
 * 
 * @author Brian Becker
 */
public class PostmanCollection implements RestCollection {

    /**
     * Get a Postman Rest Request by ID, a UUID like long string which is more
     * likely to be unique.
     * 
     * @param id
     * @return 
     */
    @Override
    public RestRequest byId(String id) {
        if(names.containsKey(id)) {
            return ids.get(id);
        } else {
            throw new RuntimeException("Request with id '" + id + "' not found.");
        }
    }

    /**
     * Get a Postman Rest Request by name.
     * 
     * @param name
     * @return 
     */
    @Override
    public RestRequest byName(String name) {
        if(names.containsKey(name)) {
            return names.get(name);
        } else {
            throw new RuntimeException("Request named '" + name + "' not found.");
        }
    }
    
    /**
     * A response code (404 Not Found, etc) read from the Postman Response
     * Data. This is what should be expected to be returned.
     */
    private static class ResponseCode {
        private Number code;
        private String name;
        private String detail;
    }
    
    /**
     * A header, read from the Postman Response Data. This is a header which
     * was returned on the first successful manual execution of the request.
     */
    private static class Header {
        private String name;
        private String key;
        private String value;
        private String description;
    }
    
    /**
     * The State object has only the "size" string, as far as has been
     * determined from various Postman output files.
     */
    private static class State {
        private String size;
    }
    
    /**
     * The ResponseRequest is a series of values which seem to have generated
     * the REST request, but it is a lot less detailed than the original
     * request (grandparent object)
     */
    private static class PostmanResponseRequest {
        private String url;
        private Map pathVariables;
        private JsonNode data;
        private String headers;
        private String dataMode;
        private String method;
        private String tests;
        private Number version;
    }
    
    /**
     * The SampleResponseData consists of the data values retrieved from the
     * request. It represents an actual request which has been generated in an
     * exploratory test.
     */
    public static class SampleResponseData {        
        private String status;
        private ResponseCode responseCode;
        private Number time;
        private List<Header> headers;
        private List<String> cookies;
        private String mime;
        private String text;
        private String language;
        private String rawDataType;
        private State state;
        private String previewType;
        private Number searchResultScrolledTo;
        private Boolean forceRaw;
        private String id;
        private String name;
        private PostmanResponseRequest request;
    }
    
    /**
     * This is a validation engine for the responses. Each and every collection
     * type requires the use of a validation class which will take the actual
     * rest request, the sample response, and a list of changes to be applied
     * to both of them programmatically. Then the request is fired off by the
     * validate, and a valid node is returned or an exception is thrown.
     */
    private static class SampleResponseValidator implements ExpectedResponse {

        private final RestRequest request;
        private final SampleResponseData data;
        private final BaseExpectedNode node;
        
        /**
         * Create a new Response Validator with a REST request, data for
         * this class, as well as the patch node.
         * 
         * @param request
         * @param data
         * @param node 
         */
        public SampleResponseValidator(RestRequest request, SampleResponseData data, BaseExpectedNode node) {
            this.request = request;
            this.data = data;
            this.node = node;
        }
        
        /**
         * Fire off the request and validate it. Both values (real and
         * expected) are patched, the equality of the expected and real
         * values are asserted, and a tree is returned if they are a
         * match.
         * 
         * @return 
         */
        @Override
        public JsonNode validate() {
            String real = "";
            if(request == null || data.text == null)
                throw new UnsupportedOperationException("Operation not supported on null ExpectedResponse");
            try {
                Response res = request.send();
                real = res.body().string();
                String expected = data.text;
                real = node.ignores.apply(real);
                expected = node.patches.apply(expected);
                expected = node.ignores.apply(expected);
                Assert.assertEquals(expected, real);
                return Json.Map.readTree(real);
            } catch (IOException ex) {
                // We want to break out of the exception if it's just a regular
                // Json parsing exception.
                if(real.equals(data.text)) {
                    return new TextNode(data.text);
                }
            } catch (Exception e) {
                throw new RuntimeException("Error while sending message during validation." + e.getMessage());
            }
            return null;
        }

        /**
         * Select a path from which to start making changes to this validator.
         * The changes will be stored as a separate Patch which will be applied
         * to the expected node.
         * 
         * @param path
         * @return 
         */
        @Override
        public ExpectedNode path(Object... path) {
            return node.path(path);
        }

        /**
         * An alternate to using the .path("object", "path") style path
         * selection, which is a little less verbose for very long paths
         * and is easier to manipulate via string manipulations.
         * 
         * @param path
         * @return 
         */
        @Override
        public ExpectedNode at(String path) {
            return node.at(path);
        }
        
    }

    /**
     * The Postman Request Data is the bulk of the data which is imported by
     * the PostmanCollection class.
     */
    private static class PostmanRequestData {
        private String id;
        private String headers;
        private String url;
        private Map pathVariables;
        private String preRequestScript;
        private RestRequest.RequestType method;
        private List<RestRequest.RequestData> data;
        private String dataMode;
        private String name;
        private String description;
        private String descriptionFormat;
        private Date time;
        private Number version;
        private List<SampleResponseData> responses;
        private String tests;
        private String currentHelper;
        private Map helperAttributes;
        private String collectionId;
        private Boolean synced;
        private String rawModeData;
    }
    
    /**
     * A PostmanRequest is a type of RestRequest which is based on Postman
     * requests stored in a collection file.
     */
    public static class PostmanRequest extends RestRequest {        
        private static final MessageFormat fmt = new MessageFormat(
                "-- ID: {0} URL: {2} Method: {5} Name: {8} --");
        
        private final PostmanRequestData data;
        
        /**
         * Create a PostmanRequest with the required data.
         * 
         * @param data 
         */
        @JsonCreator(mode = JsonCreator.Mode.DELEGATING)        
        private PostmanRequest(PostmanRequestData data) {
            this.data = data;
        }
        
        private Map requestVariables;
        private Map requestDefaultVariables;
        private Map session;
        private String[] files;
        
        /**
         * Set an environment (list of variables) on the request. This
         * environment is a local set of variables which can be called
         * on by entering specifiers such as {{var}} into the URL or
         * any request. Unfortunately, no variable substitution in requests
         * yet, as postman doesn't output this type of file.
         * 
         * @param vars
         * @return 
         */
        @Override
        public RestRequest withEnv(Map vars) {
            this.requestVariables = vars;
            return this;
        }
        
        @Override
        public String toString() {
            return fmt.format(new Object[] { data.id, data.url, data.method, data.name });
        }
        
        /**
         * Set a bunch of parameters on this REST request. These parameters
         * are specified like substitutions in Spark and many other web
         * frameworks. This just replaces the parameters from first to last
         * as they are specified.
         * 
         * @param parts
         * @return 
         */
        @Override
        public RestRequest withParams(String... parts) {
            String[] temp = StringUtils.substringsBetween(data.url, "/:", "/");
            int i = 0;
            if(temp != null && temp.length > 0) {
                for(String t : temp) {
                     data.url = data.url.replace("/:" + t + "/", "/" + parts[i++] + "/");
                }
            }
            return this;
        }
        
        /**
         * This is an alternate withParams method which is more flexible and
         * can be used to replace with a mapping of names to values.
         * 
         * @param parts
         * @return 
         */
        @Override
        public RestRequest withParams(Map parts) {
            for(String str : StringUtils.substringsBetween(data.url, "/:", "/")) {
                System.out.println(str);
                if(parts.containsKey(str)) {
                    data.url = data.url.replace("/:" + str + "/", "/" + parts.get(str) + "/");
                }
            }
            return this;
        }
        
        /**
         * Set a bunch of files to be used with this REST request. Files are
         * specified in Postman, but they must be selected on every run of
         * a file. Therefore they are available for replacement programmatically.
         * 
         * @param files
         * @return 
         */
        @Override
        public RestRequest withFiles(String... files) {
            this.files = files;
            return this;
        }
        
        /**
         * Send this request, and get an OkHttpClient response back which
         * can be evaluated. This does no checking, only providing a quick
         * way to fire off REST requests based on a transcript.
         * 
         * @return
         * @throws Exception 
         */
        @Override
        public Response send() throws Exception {
            OkHttpClient client = new OkHttpClient();
            if(this.session != null && this.session.containsKey("session")) {
                client.setCookieHandler(((RestSession)this.session.get("session")).getCookieManager());
            }
            RequestFormat format = null;
            switch(data.dataMode) {
                case "params": format = RequestFormat.MULTIPART_FORM; break;
                case "urlencoded": format = RequestFormat.URLENCODE; break;
                case "binary": format = RequestFormat.RAW; break;
                case "raw": format = RequestFormat.RAW; break;
            }
            
            Map variables = new DefaultingMap(requestVariables, requestDefaultVariables);
            Request request = RestRequestHelpers.request(data.method, data.headers, data.url, data.helperAttributes, format, data.data, data.rawModeData, variables, files);
            Response response = client.newCall(request).execute();
                        
            requestVariables = null;            
            return response;
        }
        
        /**
         * This returns an expected response, which is a predetermined response
         * which was returned by the server for this given request in the past.
         *
         * NOTE: Expected responses tend to vary because of time and other
         * factors. Make sure to remove expectations which you know the server
         * has no reason to keep.
         * 
         * @param name
         * @param diff
         * @return 
         */
        @Override
        public ExpectedResponse response(String name, BaseExpectedNode diff) {
            for(SampleResponseData r : data.responses) {
                if(r.name.equals(name)) {
                    return new SampleResponseValidator(this, r, diff);
                }
            }
            throw new RuntimeException("Response named '" + name + "' not found.");
        }
    }
    
    /**
     * This is the root of the Postman Collection, a bunch of data from
     * the JSON file. Most of this is not actually used, things like ordering
     * and folders, etc. However, the "requests" is further traversed to
     * make this collection useful.
     */
    private static class PostmanCollectionData {        
        private String id;
        private String name;
        private String description;
        private List<String> order;
        private List<String> folders;
        private Date timestamp;
        private Boolean synced;
        private String remoteLink;
        private List<PostmanRequest> requests;
    }
    
    private final Map<String, RestRequest> ids;
    private final Map<String, RestRequest> names;
    private final Map session;
    private final Map defaultVariables;
    
    /**
     * A PostmanCollection requires data from its JSON file. This class can
     * be constructed by passing a URL to a JSON file in the correct format.
     * 
     * @param data
     * @throws IOException 
     */
    private PostmanCollection(PostmanCollectionData data) throws IOException {
        ids = new HashMap<String, RestRequest>();
        names = new HashMap<String, RestRequest>();
        session = new HashMap<String, RestSession>();
        defaultVariables = new HashMap();
        for(PostmanRequest req : data.requests) {
            req.requestDefaultVariables = defaultVariables;
            req.session = session;
            ids.put(req.data.id, req);
            names.put(req.data.name, req);
        }
    }
    
    /**
     * Pass an environment to the whole collection. Not only is this permanent,
     * not being cleared on requests, it also applies to all instances of the
     * request object. This can cause numerous debugging issues, but the
     * values from these replacements will always be overloaded by local
     * variables.
     * 
     * @param variables
     * @return 
     */
    @Override
    public RestCollection withEnv(Map variables) {
        defaultVariables.clear();
        defaultVariables.putAll(variables);
        return this;
    }
    
    /**
     * Pass a Session object to the collection. This is an object which should
     * be used to preserve things such as cookies, etc.
     * 
     * @param session
     * @return 
     */
    @Override
    public RestCollection withSession(RestSession session) {
        this.session.put("session", session);
        return this;
    }
    
    /**
     * Create a Collection from a file. This takes in a JSON file and returns
     * a class of the PostmanCollection type.
     * 
     * @param collection
     * @return
     * @throws Exception 
     */
    public static RestCollection file(URL collection) throws Exception {   
        return new PostmanCollection(Json.Map.readValue(Okio.buffer(Okio.source((InputStream)collection.getContent())).readByteArray(), PostmanCollectionData.class));
    }
        
}

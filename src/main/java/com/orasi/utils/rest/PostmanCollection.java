/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.orasi.utils.rest;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.orasi.utils.types.DefaultingMap;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Request;
import com.squareup.okhttp.Response;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.text.MessageFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import okio.Okio;
import org.apache.commons.lang3.StringUtils;
import org.testng.Assert;

/**
 * The PostmanCollection allows one to load a Postman Collection file, which
 * is just a specially formatted JSON file. It describes a user-selected group
 * of queries which have been saved in Postman. The collection contains a group
 * of requests, which also potentially have a number of responses. These
 * responses were generated by making a request in Postman and then clicking
 * the bookmark icon in Postman.
 * 
 * @author Brian Becker
 */
public class PostmanCollection implements RestCollection {

    @Override
    public RestRequest byId(String id) {
        return ids.get(id);
    }

    @Override
    public RestRequest byName(String name) {
        return names.get(name);
    }
    
    private static class ResponseCode {
        private Number code;
        private String name;
        private String detail;
    }
    
    private static class Header {
        private String name;
        private String key;
        private String value;
        private String description;
    }
    
    private static class State {
        private String size;
    }
    
    private static class PostmanResponseRequest {
        private String url;
        private Map pathVariables;
        private JsonNode data;
        private String headers;
        private String dataMode;
        private String method;
        private String tests;
        private Number version;
    }
    
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class SampleResponseData implements RestValidator {
                       
        private String status;
        private ResponseCode responseCode;
        private Number time;
        private List<Header> headers;
        private List<String> cookies;
        private String mime;
        private String text;
        private String language;
        private String rawDataType;
        private State state;
        private String previewType;
        private Number searchResultScrolledTo;
        private Boolean forceRaw;
        private String id;
        private String name;
        private PostmanResponseRequest request;

        @Override
        public JsonNode validate(List<Patch> ignores, List<Patch> patches, Response res) throws Exception {
            String expect = text;
            String real = res.body().string();
            for(Patch p : ignores) {
                expect = p.apply(expect);
                real = p.apply(real);
            }
            for(Patch p : patches) {
                expect = p.apply(expect);
            }
            Assert.assertEquals(expect, real);
            ObjectMapper map = new ObjectMapper();
            return map.readTree(real);
        }
        
    }

    public static class PostmanRequest implements RestRequest {        
        private static final MessageFormat fmt = new MessageFormat(
                "-- ID: {0} URL: {2} Method: {5} Name: {8} --");
        
        private String id;
        private String headers;
        private String url;
        private Map pathVariables;
        private String preRequestScript;
        private RequestType method;
        private List<RequestData> data;
        private String dataMode;
        private String name;
        private String description;
        private String descriptionFormat;
        private Date time;
        private Number version;
        private List<SampleResponseData> responses;
        private String tests;
        private String currentHelper;
        private Map helperAttributes;
        private String collectionId;
        private Boolean synced;
        private String rawModeData;
        
        @JsonIgnore
        private Map requestVariables;
        @JsonIgnore
        private Map requestDefaultVariables;
        @JsonIgnore
        private String[] files;
        
        @Override
        public RestRequest withEnv(Map vars) {
            this.requestVariables = vars;
            return this;
        }
        
        @Override
        public String toString() {
            return fmt.format(new Object[] { id, headers, url, pathVariables, 
                    preRequestScript, method, data, dataMode, name, description,
                    descriptionFormat, time, version, responses, tests, 
                    currentHelper, helperAttributes, collectionId, synced, 
                    rawModeData });
        }
        
        @Override
        public RestRequest withParams(String... parts) {
            String[] temp = StringUtils.substringsBetween(url, "/:", "/");
            int i = 0;
            if(temp != null && temp.length > 0) {
                for(String t : temp) {
                     url = url.replace("/:" + t + "/", "/" + parts[i++] + "/");
                }
            }
            return this;
        }
        
        @Override
        public RestRequest withFiles(String... files) {
            this.files = files;
            return this;
        }
        
        @Override
        public Response send() throws Exception {
            OkHttpClient client = new OkHttpClient();
            RequestFormat format = null;
            switch(dataMode) {
                case "params": format = RequestFormat.MULTIPART_FORM; break;
                case "urlencoded": format = RequestFormat.URLENCODE; break;
                case "binary": format = RequestFormat.RAW; break;
                case "raw": format = RequestFormat.RAW; break;
            }
            
            Map variables = new DefaultingMap(requestVariables, requestDefaultVariables);            
            Request request = RestRequestHelpers.request(method, headers, url, format, data, rawModeData, variables, files);
            Response response = client.newCall(request).execute();
            
            requestVariables = null;            
            return response;
        }
        
        @Override
        public ExpectedResponse response(String name) {
            for(SampleResponseData r : this.responses) {
                if(r.name.equals(name)) {
                    return new ExpectedResponse(this, r);
                }
            }
            return new ExpectedResponse();
        }
    }
        
    private static class PostmanCollectionData {        
        private String id;
        private String name;
        private String description;
        private List<String> order;
        private List<String> folders;
        private Date timestamp;
        private Boolean synced;
        private String remoteLink;
        private List<PostmanRequest> requests;
    }
    
    private final Map<String, RestRequest> ids;
    private final Map<String, RestRequest> names;
    private final Map defaultVariables;
    
    private PostmanCollection(PostmanCollectionData data) throws IOException {
        ids = new HashMap<String, RestRequest>();
        names = new HashMap<String, RestRequest>();
        defaultVariables = new HashMap();
        for(PostmanRequest req : data.requests) {
            req.requestDefaultVariables = defaultVariables;
            ids.put(req.id, req);
            names.put(req.name, req);
        }
    }
    
    @Override
    public RestCollection withEnv(Map variables) {
        defaultVariables.clear();
        defaultVariables.putAll(variables);
        return this;
    }
    
    public static RestCollection file(URL collection) throws Exception {   
        return new PostmanCollection(Json.MAP.readValue(Okio.buffer(Okio.source((InputStream)collection.getContent())).readByteArray(), PostmanCollectionData.class));
    }
        
}

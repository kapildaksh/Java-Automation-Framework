package com.orasi.utils.test.cukes;

import cucumber.runtime.model.CucumberScenario;
import gherkin.formatter.Formatter;
import cucumber.runtime.Runtime;
import cucumber.runtime.model.CucumberExamples;
import cucumber.runtime.model.CucumberFeature;
import cucumber.runtime.model.CucumberScenarioOutline;
import cucumber.runtime.model.CucumberTagStatement;
import java.nio.file.Paths;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import org.testng.ITest;
import org.testng.SkipException;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;
import org.apache.commons.lang3.StringUtils;

/**
 * An actual TestNG test which is generated by the Test Factory,
 * CucumberNG. This is a Feature Test, which is designed for a
 * non-parallel execution of a single feature.
 * 
 * @author Brian Becker
 */
public class CucumberFeatureTest implements ITest {

    private final CucumberFeature feature;
    private final Formatter formatter;
    private final CucumberLoggingReporter reporter;
    private final Runtime runtime;
    
    private String testName;

    /**
     * The test class requires a Scenario, Formatter, Reporter, and Runtime.
     * These specify a Cucumber testing context, in which the given scenario
     * is to be run.
     * 
     * @param cf
     * @param formatter
     * @param reporter
     * @param runtime
     */
    public CucumberFeatureTest(CucumberFeature cf, Formatter formatter, CucumberLoggingReporter reporter, Runtime runtime) {
        this.feature = cf;
        this.formatter = formatter;
        this.reporter = reporter;
        this.runtime = runtime;
    }
    
    @BeforeClass
    public void setUp() {
        formatter.uri(Paths.get(feature.getPath()).getFileName().toString());        
        formatter.feature(feature.getGherkinFeature());
    }
    
    /**
     * The DataProvider which adds all the individual scenarios to the feature
     * test object. This is because we want all the scenarios to read in-order
     * to allow us to use traditional-style logging.
     * 
     * @return 
     */
    @DataProvider(name = "scenarios")
    public Iterator<Object[]> features() {
        List<Object[]> features = new LinkedList<Object[]>();
        for (CucumberTagStatement ts : feature.getFeatureElements()) {
            if(ts instanceof CucumberScenarioOutline) {
                CucumberScenarioOutline outline = (CucumberScenarioOutline) ts;
                boolean firstScenario = true;
                for (CucumberExamples examples : outline.getCucumberExamplesList()) {
                    for (CucumberScenario cs : examples.createExampleScenarios()) {
                        features.add(new Object[] { (CucumberScenario)cs, outline, firstScenario });
                        firstScenario = false;
                    }
                }
            }
            if(ts instanceof CucumberScenario) {
                features.add(new Object[] { (CucumberScenario)ts, null, false });
            }
        }        
        return features.iterator();
    }

    /**
     * The Cucumber test itself, which is executed, and a variety of exceptions
     * will be passed through Cucumber or generated if the test has been
     * determined to be skipped, or not defined.
     * 
     * @param cs Cucumber Scenario
     * @param cso Outline for Scenario, if applicable
     * @param firstScenario
     * @throws Throwable 
     */
    @Test(dataProvider = "scenarios")
    public void testCucumber(CucumberScenario cs, CucumberScenarioOutline cso, boolean firstScenario) throws Throwable {
        if(firstScenario && cso != null) {
            cso.formatOutlineScenario(formatter);
            for(CucumberExamples exs : cso.getCucumberExamplesList()) {
                formatter.examples(exs.getExamples());
            }
        }
        cs.run(formatter, reporter, runtime);
        formatter.eof();
        switch(reporter.getLastResult().getStatus()) {
            case "failed":
                throw reporter.getLastResult().getError();
            case "skipped":
                throw new SkipException("Skipped Test");
            case "undefined":
                throw new SkipException("Undefined");
        }
    }
    
    /**
     * Before the method, get the test name to stuff into the current
     * test name value.
     * @param params
     */
    @BeforeMethod(alwaysRun = true)
    public void before(Object[] params) {
        if(params.length > 0) {
            if(params[0] instanceof CucumberScenario) {
                CucumberScenario cs = (CucumberScenario) params[0];
                testName = cs.getGherkinModel().getName();
                if(params.length > 1) {
                    if(params[1] instanceof CucumberScenarioOutline) {
                        CucumberScenarioOutline cso = (CucumberScenarioOutline) params[1];
                        testName = testName + " [" + StringUtils.join(StringUtils.substringsBetween(StringUtils.normalizeSpace(cs.getVisualName()), "| ", " |"), ", ") + "]";
                    }
                }                
            }
        }
    }

    /**
     * The Test Name which is generated by the Gherkin Keyword and Model
     * Name. It will be displayed in NetBeans and Eclipse test frontends,
     * and is needed to implement ITest.
     * 
     * @return test name
     */
    @Override
    public String getTestName() {
        if(this.testName != null) {
            return this.testName;
        } else {
            return "invalid";
        }
    }

}